// SCHC Image Sender - Large Fragment Support
// Based on RFC 8724 with extended FCN for large images

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "flex.h"

#define APPLICATION_NAME "SCHC Image Sender"

// SCHC Configuration for Large Images
#define MTU_SIZE 20                   // Maximum packet size in bytes
#define RULE_ID 0x01                  // Rule ID (2 bits)
#define FCN_FINAL 0xFF                // FCN for final fragment (8 bits = 255)
#define MAX_FRAGMENTS 256             // Maximum fragments allowed (8 bits)
#define MAX_MESSAGES_PER_DAY 20       // Daily message limit (conservative)

// Image configuration
#define IMAGE_SIZE 890                // Size of compressed image
#define FRAGMENTS_PER_SESSION 20      // Send 20 fragments per session (use full daily limit)
#define HOURS_BETWEEN_SESSIONS 24     // Wait 24 hours between sessions (once per day)

// Message tracking
static uint16_t messages_sent_today = 0;
static uint16_t current_fragment = 0;
static bool transmission_complete = false;
static uint16_t last_reset_day = 0;  // Track which day we last reset the counter

// Embedded image data (you'll replace this with your actual image data)
// This is a placeholder - you need to convert your image to a C array
static const uint8_t compressed_image[890] = {
    0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,  // Offset 0000
    0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x35, 0x25, 0x28, 0x2F, 0x28, 0x21, 0x35,  // Offset 0010
    0x2F, 0x2B, 0x2F, 0x3C, 0x39, 0x35, 0x3F, 0x50, 0x85, 0x57, 0x50, 0x49, 0x49, 0x50, 0xA3, 0x75,  // Offset 0020
    0x7B, 0x61, 0x85, 0xC1, 0xAA, 0xCB, 0xC8, 0xBE, 0xAA, 0xBA, 0xB7, 0xD5, 0xF0, 0xFF, 0xFF, 0xD5,  // Offset 0030
    0xE2, 0xFF, 0xE6, 0xB7, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCE, 0xFF,  // Offset 0040
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDB, 0x00, 0x43, 0x01, 0x39, 0x3C,  // Offset 0050
    0x3C, 0x50, 0x46, 0x50, 0x9D, 0x57, 0x57, 0x9D, 0xFF, 0xDC, 0xBA, 0xDC, 0xFF, 0xFF, 0xFF, 0xFF,  // Offset 0060
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // Offset 0070
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // Offset 0080
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0,  // Offset 0090
    0x00, 0x11, 0x08, 0x00, 0x5A, 0x00, 0x5A, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11,  // Offset 00A0
    0x01, 0xFF, 0xC4, 0x00, 0x19, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // Offset 00B0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x05, 0xFF, 0xC4, 0x00, 0x2B,  // Offset 00C0
    0x10, 0x00, 0x02, 0x02, 0x01, 0x03, 0x02, 0x06, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,  // Offset 00D0
    0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x12, 0x21, 0x31, 0x32, 0x41, 0x04, 0x13, 0x22, 0x33, 0x51,  // Offset 00E0
    0x61, 0x71, 0x14, 0x23, 0x52, 0xA1, 0x81, 0xB1, 0xF0, 0xFF, 0xC4, 0x00, 0x14, 0x01, 0x01, 0x00,  // Offset 00F0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,  // Offset 0100
    0xC4, 0x00, 0x14, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // Offset 0110
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11,  // Offset 0120
    0x00, 0x3F, 0x00, 0xA9, 0x0B, 0x3A, 0xCA, 0x29, 0x6A, 0xB3, 0x0B, 0x84, 0x4E, 0xCF, 0x71, 0x81,  // Offset 0130
    0xD1, 0x18, 0x58, 0x87, 0x20, 0x1C, 0x9C, 0x34, 0x59, 0x6D, 0x2A, 0x4B, 0x0D, 0x01, 0x99, 0xF0,  // Offset 0140
    0x52, 0x0F, 0x31, 0x16, 0xD8, 0x3A, 0xF9, 0xDD, 0x33, 0xA1, 0xD3, 0x90, 0x1D, 0x3C, 0x3C, 0xA0,  // Offset 0150
    0x5D, 0x1E, 0x26, 0xB8, 0x60, 0x4F, 0x52, 0xCA, 0x16, 0xDB, 0xBC, 0xBA, 0xDC, 0x79, 0x72, 0xE3,  // Offset 0160
    0xE8, 0x09, 0x59, 0x66, 0x9D, 0x97, 0x24, 0xBC, 0xC9, 0xFF, 0x00, 0x36, 0x04, 0x9C, 0x9E, 0x11,  // Offset 0170
    0x4F, 0xD3, 0xCF, 0xE8, 0x0A, 0xD3, 0xD4, 0x0B, 0x7D, 0xC6, 0x35, 0x3D, 0x40, 0xB7, 0xDC, 0x60,  // Offset 0180
    0x74, 0x51, 0xC8, 0x35, 0x2C, 0xB6, 0xBE, 0x8E, 0x4B, 0x70, 0x29, 0x05, 0x9D, 0xFB, 0x16, 0x4C,  // Offset 0190
    0x8A, 0x92, 0x5B, 0x87, 0xCD, 0x8F, 0x76, 0x05, 0xDE, 0x24, 0x9A, 0x6B, 0x29, 0x99, 0xB4, 0x38,  // Offset 01A0
    0x27, 0x1F, 0x82, 0x90, 0x9E, 0xBE, 0x9D, 0xCA, 0x24, 0x06, 0x7F, 0x0D, 0x44, 0x94, 0x3D, 0x6F,  // Offset 01B0
    0x1F, 0x46, 0x4B, 0x73, 0xE6, 0x4B, 0x57, 0x39, 0xC1, 0xE8, 0x4E, 0xE5, 0x1C, 0xB5, 0xBE, 0x9E,  // Offset 01C0
    0x4C, 0x14, 0x43, 0x5C, 0xF7, 0xE1, 0x01, 0x6A, 0x2B, 0xD2, 0xB2, 0xF9, 0x65, 0xC0, 0x70, 0x12,  // Offset 01D0
    0xAB, 0xAC, 0x17, 0x7B, 0x81, 0xAB, 0xDC, 0x3A, 0xEF, 0x70, 0x0E, 0xA5, 0xB5, 0x35, 0xF7, 0xB1,  // Offset 01E0
    0xD2, 0x92, 0x4D, 0xBC, 0xEC, 0x05, 0x8D, 0x0E, 0x4D, 0xEC, 0x46, 0xC7, 0x9E, 0x40, 0x2E, 0x6E,  // Offset 01F0
    0x4F, 0x08, 0x6A, 0x6B, 0x76, 0x3F, 0x57, 0x48, 0x95, 0x41, 0xD9, 0x66, 0x17, 0x1D, 0xCD, 0x52,  // Offset 0200
    0x96, 0x97, 0xA2, 0x0B, 0x20, 0x56, 0x29, 0x70, 0x89, 0xDD, 0x26, 0xAC, 0x51, 0x6F, 0x66, 0x1A,  // Offset 0210
    0xA6, 0xF1, 0xEA, 0xD9, 0xAE, 0x48, 0x5F, 0x73, 0x94, 0xA2, 0xDA, 0xC6, 0x37, 0x40, 0x4A, 0xCB,  // Offset 0220
    0x5D, 0x9D, 0xB1, 0x15, 0xC2, 0x34, 0x78, 0x78, 0xE9, 0x87, 0xE4, 0xCC, 0xA3, 0x9B, 0x14, 0x4D,  // Offset 0230
    0xAB, 0x64, 0x01, 0x00, 0x19, 0xDB, 0x81, 0x1A, 0x1F, 0xEE, 0x8F, 0x6F, 0xBA, 0x4F, 0xC3, 0x6F,  // Offset 0240
    0x31, 0xEF, 0xEB, 0x60, 0x4A, 0x4F, 0xD4, 0xDB, 0xED, 0xC0, 0x8B, 0xA1, 0xA7, 0xC0, 0xD0, 0x6F,  // Offset 0250
    0xA9, 0x76, 0x28, 0xA0, 0xAB, 0xAD, 0xCD, 0xEF, 0x9F, 0xE8, 0x01, 0x07, 0xE5, 0x41, 0x25, 0xD7,  // Offset 0260
    0x2E, 0x7E, 0x8B, 0xC3, 0x18, 0xDC, 0xC7, 0x19, 0x37, 0x3D, 0x4F, 0x76, 0xCD, 0x51, 0x7B, 0x6C,  // Offset 0270
    0x03, 0xC1, 0xFE, 0xE1, 0x9B, 0xC4, 0x63, 0x52, 0xC1, 0x75, 0x24, 0xB2, 0xF1, 0xB9, 0x92, 0x52,  // Offset 0280
    0xD7, 0x36, 0xC0, 0xBC, 0x23, 0xFB, 0xF3, 0x7F, 0x05, 0x5B, 0x16, 0xB5, 0x88, 0xE7, 0xE5, 0x0C,  // Offset 0290
    0xB7, 0x92, 0x40, 0x56, 0x10, 0xC2, 0xFB, 0x1F, 0x01, 0xC1, 0xC0, 0x79, 0xF4, 0x27, 0x0B, 0x30,  // Offset 02A0
    0xFB, 0x8D, 0xE2, 0x76, 0x79, 0xF9, 0xE0, 0xEA, 0x9E, 0x7C, 0xA7, 0xF9, 0x17, 0xC5, 0xF5, 0x44,  // Offset 02B0
    0x04, 0x83, 0x4B, 0x39, 0x63, 0x58, 0x9C, 0x92, 0x7D, 0xBB, 0x12, 0xCF, 0x18, 0xEC, 0x57, 0x2B,  // Offset 02C0
    0x46, 0xEB, 0x3F, 0x40, 0x45, 0x1A, 0x2A, 0xE9, 0xE4, 0x8C, 0x23, 0x99, 0xE1, 0x3D, 0x8D, 0x15,  // Offset 02D0
    0xAF, 0x48, 0x15, 0x70, 0xF3, 0x60, 0xE3, 0x9D, 0x3F, 0x66, 0x59, 0xD3, 0x2A, 0x9F, 0xAB, 0x8E,  // Offset 02E0
    0xCC, 0xD5, 0x06, 0x52, 0xD8, 0x79, 0x94, 0xCA, 0x38, 0xDF, 0x1B, 0x01, 0x08, 0xB7, 0xA5, 0x63,  // Offset 02F0
    0x8C, 0x06, 0xB7, 0xAA, 0xD8, 0xA6, 0x80, 0x96, 0x22, 0x92, 0xEC, 0x56, 0xAC, 0x46, 0x2E, 0x4F,  // Offset 0300
    0x94, 0x00, 0xBE, 0xF7, 0x07, 0xA6, 0x1B, 0xCB, 0xFD, 0x19, 0xFC, 0xFB, 0xBF, 0x9F, 0xF4, 0x81,  // Offset 0310
    0x27, 0x99, 0x37, 0xF2, 0x0C, 0x81, 0x5A, 0x92, 0xD1, 0x0C, 0x70, 0xB2, 0x4F, 0xC5, 0xF5, 0xA4,  // Offset 0320
    0x53, 0xC3, 0xFB, 0x2B, 0xF2, 0x4B, 0xC5, 0x7B, 0xC0, 0x4B, 0x19, 0xEF, 0xB8, 0x66, 0xF3, 0x14,  // Offset 0330
    0xFB, 0x9C, 0xFB, 0x05, 0x71, 0x20, 0x1A, 0xB8, 0x3C, 0x7E, 0x4B, 0xA1, 0x63, 0xC0, 0xC8, 0x06,  // Offset 0340
    0x5B, 0x16, 0xAD, 0x91, 0x45, 0x20, 0x06, 0x5B, 0x61, 0xA6, 0xC9, 0x46, 0x3B, 0x34, 0x34, 0xEC,  // Offset 0350
    0x7E, 0x5A, 0x8C, 0x79, 0x7C, 0xB1, 0xAE, 0xF7, 0xDF, 0xFD, 0xD8, 0x9D, 0x9C, 0x20, 0x13, 0x88,  // Offset 0360
    0xE4, 0x98, 0xF6, 0x74, 0xC7, 0xFC, 0x8E, 0x07, 0xFF, 0xD9,  // Offset 0370
};

//CRC-32 para RCS como recomendado por RFC 8724
static uint32_t calculate_crc32(const uint8_t *data, uint16_t length) {
    uint32_t crc = 0xFFFFFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;  // CRC-32 polynomial
            } else {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}

// Check if we can send messages today and reset counter if new day
static bool can_send_messages_today(void) {
    time_t now = FLEX_TimeGet();
    uint16_t current_day = (uint16_t)(now / 86400);  // Days since epoch
    
    // Check if it's a new day
    if (current_day != last_reset_day) {
        printf("New day detected (day %d -> %d), resetting daily message counter\n", 
               last_reset_day, current_day);
        printf("Image progress: fragment %d (will continue transmission)\n", current_fragment);
        messages_sent_today = 0;  // Only reset message counter, keep image progress
        last_reset_day = current_day;
        
        // Only reset transmission state if previous image was complete AND we want a new image
        if (transmission_complete) {
            printf("Previous image complete, preparing for new transmission\n");
            current_fragment = 0;
            transmission_complete = false;
        }
    }
    
    return messages_sent_today < MAX_MESSAGES_PER_DAY;
}

// Send SCHC fragment with 8-bit FCN for large images
static int send_image_fragment(uint16_t fragment_num, uint16_t total_fragments, 
                              const uint8_t *data, uint8_t data_len) {
    uint8_t packet[MTU_SIZE];
    memset(packet, 0, MTU_SIZE);
    
    bool is_final = (fragment_num == total_fragments - 1);
    uint8_t fcn = is_final ? FCN_FINAL : (fragment_num & 0xFF);
    
    if (is_final) {
        // Final fragment: RuleID(2)|FCN(8)|RCS(32)|payload|padding
        uint32_t rcs = calculate_crc32(compressed_image, IMAGE_SIZE);
        
        // Pack: RuleID(2) + FCN(6) in byte 0, then FCN(2) + RCS(24) in bytes 1-3, RCS(8) in byte 4
        packet[0] = (RULE_ID << 6) | ((fcn >> 2) & 0x3F);  // RuleID(2) + FCN[7:2]
        packet[1] = ((fcn & 0x03) << 6) | ((rcs >> 18) & 0x3F);  // FCN[1:0] + RCS[23:18]
        packet[2] = (rcs >> 10) & 0xFF;  // RCS[17:10]
        packet[3] = (rcs >> 2) & 0xFF;   // RCS[9:2]
        packet[4] = (rcs << 6) & 0xC0;   // RCS[1:0] + padding
        
        // Copy payload starting from byte 5
        uint8_t payload_space = MTU_SIZE - 5;  // 15 bytes for payload
        uint8_t copy_len = (data_len <= payload_space) ? data_len : payload_space;
        memcpy(&packet[5], data, copy_len);
        
        printf("Final fragment %d: FCN=%d, RCS=0x%08lX, payload=%d bytes\n", 
               fragment_num, fcn, (unsigned long)rcs, copy_len);
    } else {
        // Normal fragment: RuleID(2)|FCN(8)|payload
        // Use simple approach: RuleID in upper 2 bits, FCN in lower 6 bits of byte 0
        // Then use full FCN in byte 1 if needed for >63 fragments
        packet[0] = (RULE_ID << 6) | (fcn & 0x3F);  // RuleID(2) + FCN[5:0]
        packet[1] = (fcn >> 6) & 0x03;              // FCN[7:6] in lower 2 bits
        
        // Copy payload starting from byte 2 for fragments >63, byte 1 for fragments ≤63
        uint8_t payload_start = (fcn > 63) ? 2 : 1;
        uint8_t payload_space = MTU_SIZE - payload_start;
        uint8_t copy_len = (data_len <= payload_space) ? data_len : payload_space;
        memcpy(&packet[payload_start], data, copy_len);
        
        printf("Fragment %d: FCN=%d, payload=%d bytes, payload_start=%d\n", 
               fragment_num, fcn, copy_len, payload_start);
    }
    
    // Print the exact binary packet being sent
    printf("Binary packet (20 bytes): ");
    for (int i = 0; i < MTU_SIZE; i++) {
        printf("%02X ", packet[i]);
    }
    printf("\n");
    
    printf("FLEX will convert this binary to hex for satellite transmission\n");
    
    return FLEX_MessageSchedule(packet, MTU_SIZE);
}

// Send batch of image fragments
static void send_image_batch(void) {
    if (transmission_complete) {
        printf("Image transmission already complete\n");
        return;
    }
    
    // Calculate total fragments needed
    uint16_t fragments_needed = (IMAGE_SIZE + 18) / 19;  // 19 bytes per normal fragment
    uint16_t fragments_sent_this_session = 0;
    
    printf("=== IMAGE TRANSMISSION SESSION ===\n");
    printf("Image size: %d bytes\n", IMAGE_SIZE);
    printf("Total fragments needed: %d\n", fragments_needed);
    printf("Starting from fragment: %d\n", current_fragment);
    
    // Send fragments in batches
    while (current_fragment < fragments_needed && 
           fragments_sent_this_session < FRAGMENTS_PER_SESSION &&
           messages_sent_today < MAX_MESSAGES_PER_DAY) {
        
        bool is_final = (current_fragment == fragments_needed - 1);
        uint16_t offset = current_fragment * 19;  // 19 bytes per fragment
        uint8_t payload_size;
        
        if (is_final) {
            // Final fragment - limited by CRC overhead
            uint16_t remaining = IMAGE_SIZE - offset;
            payload_size = (remaining <= 15) ? remaining : 15;  // 15 bytes max for final
        } else {
            // Normal fragment
            uint16_t remaining = IMAGE_SIZE - offset;
            payload_size = (remaining >= 19) ? 19 : remaining;
        }
        
        int result = send_image_fragment(current_fragment, fragments_needed,
                                       &compressed_image[offset], payload_size);
        
        if (result == 0) {
            printf("Fragment %d sent successfully\n", current_fragment);
            current_fragment++;
            fragments_sent_this_session++;
            messages_sent_today++;
            
            if (current_fragment >= fragments_needed) {
                transmission_complete = true;
                printf("=== IMAGE TRANSMISSION COMPLETE ===\n");
                break;
            }
        } else {
            printf("Failed to send fragment %d\n", current_fragment);
            break;
        }
    }
    
    printf("Session complete: sent %d fragments\n", fragments_sent_this_session);
    printf("Progress: %d/%d fragments (%d%%)\n", 
           current_fragment, fragments_needed, 
           (current_fragment * 100) / fragments_needed);
    printf("Messages sent today: %d/%d\n", messages_sent_today, MAX_MESSAGES_PER_DAY);
}

// Main transmission function
static time_t send_image_session(void) {
    // Check daily limit with automatic reset
    if (!can_send_messages_today()) {
        printf("Daily message limit reached (%d/%d)\n", 
               messages_sent_today, MAX_MESSAGES_PER_DAY);
        return FLEX_HoursFromNow(24);  // Try again tomorrow
    }
    
    if (transmission_complete) {
        printf("Image transmission complete. Starting new image immediately.\n");
        // Reset for next image immediately, not waiting for next day
        current_fragment = 0;
        transmission_complete = false;
        // Don't reset messages_sent_today here - let daily reset handle it
    }
    
    // Send batch of fragments
    send_image_batch();
    
    printf("Next session in %d hours\n", HOURS_BETWEEN_SESSIONS);
    printf("=================================\n\n");
    
    // Schedule next session
    return FLEX_HoursFromNow(HOURS_BETWEEN_SESSIONS);
}

void FLEX_AppInit() {
    printf("%s\n", APPLICATION_NAME);
    printf("Image size: %d bytes\n", IMAGE_SIZE);
    printf("MTU size: %d bytes\n", MTU_SIZE);
    printf("Max fragments: %d\n", MAX_FRAGMENTS);
    printf("Fragments per session: %d\n", FRAGMENTS_PER_SESSION);
    printf("Hours between sessions: %d\n", HOURS_BETWEEN_SESSIONS);
    
    // Initialize daily reset tracking
    time_t now = FLEX_TimeGet();
    last_reset_day = (uint16_t)(now / 86400);
    printf("Initialized on day %d\n", last_reset_day);
    
    printf("Starting image transmission...\n\n");
    
    // Schedule first transmission session
    FLEX_JobSchedule(send_image_session, FLEX_ASAP());
}