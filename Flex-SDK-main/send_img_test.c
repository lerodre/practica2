// SCHC enviador de imagenes - soporte de fragmentos grandes
// basado en RFC 8724 con FCN extendido para imagenes grandes

#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include "flex.h"

#define APPLICATION_NAME "SCHC Image Sender"

// configuracion SCHC para FCN de 6-bit
#define MTU_SIZE 20                   // tamano maximo de paquete en bytes
#define RULE_ID 0x01                  // rule ID (2 bits)
#define FCN_ALL1 0x3F                 // FCN para fragmento final (6 bits = 63 = All-1)
#define MAX_FRAGMENTS 64              // maximo fragmentos permitidos (6 bits = 0-63)
#define MAX_MESSAGES_PER_DAY 20       // limite diario de mensajes (conservador)

// configuracion de imagen
#define IMAGE_SIZE 890                // tamano de imagen comprimida
#define FRAGMENTS_PER_SESSION 20      // enviar 20 fragmentos por sesion (usar limite diario completo)
#define HOURS_BETWEEN_SESSIONS 24     // esperar 24 horas entre sesiones (una vez por dia)

// seguimiento de mensajes
static uint16_t messages_sent_today = 0;
static uint16_t current_fragment = 0;
static bool transmission_complete = false;
static uint16_t last_reset_day = 0;  // rastrear que dia reseteamos el contador por ultima vez

// datos de imagen embebidos
// esto es un placeholder - necesitas convertir tu imagen a un arreglo C
static const uint8_t compressed_image[890] = {
    0xFF, 0xD8, 0xFF, 0xE0, 0x00, 0x10, 0x4A, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00, 0x00, 0x01,  // offset 0000
    0x00, 0x01, 0x00, 0x00, 0xFF, 0xDB, 0x00, 0x43, 0x00, 0x35, 0x25, 0x28, 0x2F, 0x28, 0x21, 0x35,  // offset 0010
    0x2F, 0x2B, 0x2F, 0x3C, 0x39, 0x35, 0x3F, 0x50, 0x85, 0x57, 0x50, 0x49, 0x49, 0x50, 0xA3, 0x75,  // offset 0020
    0x7B, 0x61, 0x85, 0xC1, 0xAA, 0xCB, 0xC8, 0xBE, 0xAA, 0xBA, 0xB7, 0xD5, 0xF0, 0xFF, 0xFF, 0xD5,  // offset 0030
    0xE2, 0xFF, 0xE6, 0xB7, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xCE, 0xFF,  // offset 0040
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDB, 0x00, 0x43, 0x01, 0x39, 0x3C,  // offset 0050
    0x3C, 0x50, 0x46, 0x50, 0x9D, 0x57, 0x57, 0x9D, 0xFF, 0xDC, 0xBA, 0xDC, 0xFF, 0xFF, 0xFF, 0xFF,  // offset 0060
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // offset 0070
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,  // offset 0080
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC0,  // offset 0090
    0x00, 0x11, 0x08, 0x00, 0x5A, 0x00, 0x5A, 0x03, 0x01, 0x22, 0x00, 0x02, 0x11, 0x01, 0x03, 0x11,  // offset 00A0
    0x01, 0xFF, 0xC4, 0x00, 0x19, 0x00, 0x00, 0x03, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,  // offset 00B0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x00, 0x05, 0xFF, 0xC4, 0x00, 0x2B,  // offset 00C0
    0x10, 0x00, 0x02, 0x02, 0x01, 0x03, 0x02, 0x06, 0x01, 0x04, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,  // offset 00D0
    0x00, 0x00, 0x01, 0x02, 0x03, 0x11, 0x12, 0x21, 0x31, 0x32, 0x41, 0x04, 0x13, 0x22, 0x33, 0x51,  // offset 00E0
    0x61, 0x71, 0x14, 0x23, 0x52, 0xA1, 0x81, 0xB1, 0xF0, 0xFF, 0xC4, 0x00, 0x14, 0x01, 0x01, 0x00,  // offset 00F0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,  // offset 0100
    0xC4, 0x00, 0x14, 0x11, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  // offset 0110
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11,  // offset 0120
    0x00, 0x3F, 0x00, 0xA9, 0x0B, 0x3A, 0xCA, 0x29, 0x6A, 0xB3, 0x0B, 0x84, 0x4E, 0xCF, 0x71, 0x81,  // offset 0130
    0xD1, 0x18, 0x58, 0x87, 0x20, 0x1C, 0x9C, 0x34, 0x59, 0x6D, 0x2A, 0x4B, 0x0D, 0x01, 0x99, 0xF0,  // offset 0140
    0x52, 0x0F, 0x31, 0x16, 0xD8, 0x3A, 0xF9, 0xDD, 0x33, 0xA1, 0xD3, 0x90, 0x1D, 0x3C, 0x3C, 0xA0,  // offset 0150
    0x5D, 0x1E, 0x26, 0xB8, 0x60, 0x4F, 0x52, 0xCA, 0x16, 0xDB, 0xBC, 0xBA, 0xDC, 0x79, 0x72, 0xE3,  // offset 0160
    0xE8, 0x09, 0x59, 0x66, 0x9D, 0x97, 0x24, 0xBC, 0xC9, 0xFF, 0x00, 0x36, 0x04, 0x9C, 0x9E, 0x11,  // offset 0170
    0x4F, 0xD3, 0xCF, 0xE8, 0x0A, 0xD3, 0xD4, 0x0B, 0x7D, 0xC6, 0x35, 0x3D, 0x40, 0xB7, 0xDC, 0x60,  // offset 0180
    0x74, 0x51, 0xC8, 0x35, 0x2C, 0xB6, 0xBE, 0x8E, 0x4B, 0x70, 0x29, 0x05, 0x9D, 0xFB, 0x16, 0x4C,  // offset 0190
    0x8A, 0x92, 0x5B, 0x87, 0xCD, 0x8F, 0x76, 0x05, 0xDE, 0x24, 0x9A, 0x6B, 0x29, 0x99, 0xB4, 0x38,  // offset 01A0
    0x27, 0x1F, 0x82, 0x90, 0x9E, 0xBE, 0x9D, 0xCA, 0x24, 0x06, 0x7F, 0x0D, 0x44, 0x94, 0x3D, 0x6F,  // offset 01B0
    0x1F, 0x46, 0x4B, 0x73, 0xE6, 0x4B, 0x57, 0x39, 0xC1, 0xE8, 0x4E, 0xE5, 0x1C, 0xB5, 0xBE, 0x9E,  // offset 01C0
    0x4C, 0x14, 0x43, 0x5C, 0xF7, 0xE1, 0x01, 0x6A, 0x2B, 0xD2, 0xB2, 0xF9, 0x65, 0xC0, 0x70, 0x12,  // offset 01D0
    0xAB, 0xAC, 0x17, 0x7B, 0x81, 0xAB, 0xDC, 0x3A, 0xEF, 0x70, 0x0E, 0xA5, 0xB5, 0x35, 0xF7, 0xB1,  // offset 01E0
    0xD2, 0x92, 0x4D, 0xBC, 0xEC, 0x05, 0x8D, 0x0E, 0x4D, 0xEC, 0x46, 0xC7, 0x9E, 0x40, 0x2E, 0x6E,  // offset 01F0
    0x4F, 0x08, 0x6A, 0x6B, 0x76, 0x3F, 0x57, 0x48, 0x95, 0x41, 0xD9, 0x66, 0x17, 0x1D, 0xCD, 0x52,  // offset 0200
    0x96, 0x97, 0xA2, 0x0B, 0x20, 0x56, 0x29, 0x70, 0x89, 0xDD, 0x26, 0xAC, 0x51, 0x6F, 0x66, 0x1A,  // offset 0210
    0xA6, 0xF1, 0xEA, 0xD9, 0xAE, 0x48, 0x5F, 0x73, 0x94, 0xA2, 0xDA, 0xC6, 0x37, 0x40, 0x4A, 0xCB,  // offset 0220
    0x5D, 0x9D, 0xB1, 0x15, 0xC2, 0x34, 0x78, 0x78, 0xE9, 0x87, 0xE4, 0xCC, 0xA3, 0x9B, 0x14, 0x4D,  // offset 0230
    0xAB, 0x64, 0x01, 0x00, 0x19, 0xDB, 0x81, 0x1A, 0x1F, 0xEE, 0x8F, 0x6F, 0xBA, 0x4F, 0xC3, 0x6F,  // offset 0240
    0x31, 0xEF, 0xEB, 0x60, 0x4A, 0x4F, 0xD4, 0xDB, 0xED, 0xC0, 0x8B, 0xA1, 0xA7, 0xC0, 0xD0, 0x6F,  // offset 0250
    0xA9, 0x76, 0x28, 0xA0, 0xAB, 0xAD, 0xCD, 0xEF, 0x9F, 0xE8, 0x01, 0x07, 0xE5, 0x41, 0x25, 0xD7,  // offset 0260
    0x2E, 0x7E, 0x8B, 0xC3, 0x18, 0xDC, 0xC7, 0x19, 0x37, 0x3D, 0x4F, 0x76, 0xCD, 0x51, 0x7B, 0x6C,  // offset 0270
    0x03, 0xC1, 0xFE, 0xE1, 0x9B, 0xC4, 0x63, 0x52, 0xC1, 0x75, 0x24, 0xB2, 0xF1, 0xB9, 0x92, 0x52,  // offset 0280
    0xD7, 0x36, 0xC0, 0xBC, 0x23, 0xFB, 0xF3, 0x7F, 0x05, 0x5B, 0x16, 0xB5, 0x88, 0xE7, 0xE5, 0x0C,  // offset 0290
    0xB7, 0x92, 0x40, 0x56, 0x10, 0xC2, 0xFB, 0x1F, 0x01, 0xC1, 0xC0, 0x79, 0xF4, 0x27, 0x0B, 0x30,  // offset 02A0
    0xFB, 0x8D, 0xE2, 0x76, 0x79, 0xF9, 0xE0, 0xEA, 0x9E, 0x7C, 0xA7, 0xF9, 0x17, 0xC5, 0xF5, 0x44,  // offset 02B0
    0x04, 0x83, 0x4B, 0x39, 0x63, 0x58, 0x9C, 0x92, 0x7D, 0xBB, 0x12, 0xCF, 0x18, 0xEC, 0x57, 0x2B,  // offset 02C0
    0x46, 0xEB, 0x3F, 0x40, 0x45, 0x1A, 0x2A, 0xE9, 0xE4, 0x8C, 0x23, 0x99, 0xE1, 0x3D, 0x8D, 0x15,  // offset 02D0
    0xAF, 0x48, 0x15, 0x70, 0xF3, 0x60, 0xE3, 0x9D, 0x3F, 0x66, 0x59, 0xD3, 0x2A, 0x9F, 0xAB, 0x8E,  // offset 02E0
    0xCC, 0xD5, 0x06, 0x52, 0xD8, 0x79, 0x94, 0xCA, 0x38, 0xDF, 0x1B, 0x01, 0x08, 0xB7, 0xA5, 0x63,  // offset 02F0
    0x8C, 0x06, 0xB7, 0xAA, 0xD8, 0xA6, 0x80, 0x96, 0x22, 0x92, 0xEC, 0x56, 0xAC, 0x46, 0x2E, 0x4F,  // offset 0300
    0x94, 0x00, 0xBE, 0xF7, 0x07, 0xA6, 0x1B, 0xCB, 0xFD, 0x19, 0xFC, 0xFB, 0xBF, 0x9F, 0xF4, 0x81,  // offset 0310
    0x27, 0x99, 0x37, 0xF2, 0x0C, 0x81, 0x5A, 0x92, 0xD1, 0x0C, 0x70, 0xB2, 0x4F, 0xC5, 0xF5, 0xA4,  // offset 0320
    0x53, 0xC3, 0xFB, 0x2B, 0xF2, 0x4B, 0xC5, 0x7B, 0xC0, 0x4B, 0x19, 0xEF, 0xB8, 0x66, 0xF3, 0x14,  // offset 0330
    0xFB, 0x9C, 0xFB, 0x05, 0x71, 0x20, 0x1A, 0xB8, 0x3C, 0x7E, 0x4B, 0xA1, 0x63, 0xC0, 0xC8, 0x06,  // offset 0340
    0x5B, 0x16, 0xAD, 0x91, 0x45, 0x20, 0x06, 0x5B, 0x61, 0xA6, 0xC9, 0x46, 0x3B, 0x34, 0x34, 0xEC,  // offset 0350
    0x7E, 0x5A, 0x8C, 0x79, 0x7C, 0xB1, 0xAE, 0xF7, 0xDF, 0xFD, 0xD8, 0x9D, 0x9C, 0x20, 0x13, 0x88,  // offset 0360
    0xE4, 0x98, 0xF6, 0x74, 0xC7, 0xFC, 0x8E, 0x07, 0xFF, 0xD9,  // offset 0370
};

//CRC-32 
static uint32_t calculate_crc32(const uint8_t *data, uint16_t length) {
    uint32_t crc = 0xFFFFFFFF;
    
    for (uint16_t i = 0; i < length; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 1) {
                crc = (crc >> 1) ^ 0xEDB88320;  // polinomio CRC-32
            } else {
                crc >>= 1;
            }
        }
    }
    return ~crc;
}

// verificar si podemos enviar mensajes hoy y resetear contador si es nuevo dia
static bool can_send_messages_today(void) {
    time_t now = FLEX_TimeGet();
    uint16_t current_day = (uint16_t)(now / 86400);  // dias desde epoch
    
    // verificar si es un dia nuevo
    if (current_day != last_reset_day) {
        printf("New day detected (day %d -> %d), resetting daily message counter\n", 
               last_reset_day, current_day);
        printf("Image progress: fragment %d (will continue transmission)\n", current_fragment);
        messages_sent_today = 0;  // solo resetear contador de mensajes, mantener progreso de imagen
        last_reset_day = current_day;
        
        // solo resetear estado de transmision si imagen previa estaba completa Y queremos nueva imagen
        if (transmission_complete) {
            printf("Previous image complete, preparing for new transmission\n");
            current_fragment = 0;
            transmission_complete = false;
        }
    }
    
    return messages_sent_today < MAX_MESSAGES_PER_DAY;
}

// enviar fragmento SCHC con FCN de 6-bit 
static int send_image_fragment(uint16_t fragment_num, uint16_t total_fragments, 
                              const uint8_t *data, uint8_t data_len) {
    uint8_t packet[MTU_SIZE];
    memset(packet, 0, MTU_SIZE);
    
    bool is_final = (fragment_num == total_fragments - 1);
    uint8_t fcn;
    
    if (is_final) {
        // fragmento final siempre usa FCN = 63 (patron All-1 para 6 bits)
        fcn = FCN_ALL1;
    } else {
        // orden inverso: primer fragmento = 62, segundo = 61, ..., penultimo = mayor restante
        // FCN = (total_fragments - 2) - fragment_num
        // esto asegura: fragmento 0 â†’ FCN (total-2), fragmento 1 â†’ FCN (total-3), etc.
        fcn = (total_fragments - 2) - fragment_num;
        
        // verificacion de seguridad: FCN debe estar en rango 0-62 para fragmentos normales
        if (fcn > 62) {
            printf("ERROR: Too many fragments for 6-bit FCN! Fragment %d would need FCN %d\n", 
                   fragment_num, fcn);
            return -1;
        }
    }
    
    if (is_final) {
        // fragmento final: RuleID(2)|FCN(6)|RCS(32)|payload|padding
        uint32_t rcs = calculate_crc32(compressed_image, IMAGE_SIZE);
        
        // empacar: RuleID(2) + FCN(6) en byte 0, luego RCS(32) en bytes 1-4
        packet[0] = (RULE_ID << 6) | (fcn & 0x3F);  // RuleID(2) + FCN[5:0]
        packet[1] = (rcs >> 24) & 0xFF;  // RCS[31:24]
        packet[2] = (rcs >> 16) & 0xFF;  // RCS[23:16]
        packet[3] = (rcs >> 8) & 0xFF;   // RCS[15:8]
        packet[4] = rcs & 0xFF;          // RCS[7:0]
        
        // copiar payload comenzando desde byte 5
        uint8_t payload_space = MTU_SIZE - 5;  // 15 bytes para payload
        uint8_t copy_len = (data_len <= payload_space) ? data_len : payload_space;
        memcpy(&packet[5], data, copy_len);
        
        printf("Final fragment %d: FCN=%d (All-1), RCS=0x%08lX, payload=%d bytes\n", 
               fragment_num, fcn, (unsigned long)rcs, copy_len);
    } else {
        // fragmento normal: RuleID(2)|FCN(6)|payload
        packet[0] = (RULE_ID << 6) | (fcn & 0x3F);  // RuleID(2) + FCN[5:0]
        
        // copiar payload comenzando desde byte 1
        uint8_t payload_space = MTU_SIZE - 1;  // 19 bytes para payload
        uint8_t copy_len = (data_len <= payload_space) ? data_len : payload_space;
        memcpy(&packet[1], data, copy_len);
        
        printf("Fragment %d: FCN=%d, payload=%d bytes\n", 
               fragment_num, fcn, copy_len);
    }
    
    // imprimir el paquete binario exacto que se envia
    printf("Binary packet (20 bytes): ");
    for (int i = 0; i < MTU_SIZE; i++) {
        printf("%02X ", packet[i]);
    }
    printf("\n");
    
    printf("FLEX will convert this binary to hex for satellite transmission\n");
    
    return FLEX_MessageSchedule(packet, MTU_SIZE);
}

// enviar lote de fragmentos de imagen
static void send_image_batch(void) {
    if (transmission_complete) {
        printf("Image transmission already complete\n");
        return;
    }
    
    // calcular fragmentos totales necesarios (FCN de 6-bit permite max 64 fragmentos: 0-63)
    uint16_t fragments_needed = (IMAGE_SIZE + 18) / 19;  // 19 bytes por fragmento normal
    
    // verificar si cabe en FCN de 6-bit (max 64 fragmentos)
    if (fragments_needed > MAX_FRAGMENTS) {
        printf("ERROR: Image too large! Needs %d fragments but 6-bit FCN only allows %d\n", 
               fragments_needed, MAX_FRAGMENTS);
        return;
    }
    
    uint16_t fragments_sent_this_session = 0;
    
    printf("=== IMAGE TRANSMISSION SESSION (6-bit FCN) ===\n");
    printf("Image size: %d bytes\n", IMAGE_SIZE);
    printf("Total fragments needed: %d (fits in 6-bit FCN)\n", fragments_needed);
    printf("Starting from fragment: %d\n", current_fragment);
    printf("FCN mapping: Fragment 0â†’FCN %d, Fragment 1â†’FCN %d, ..., Finalâ†’FCN 63\n",
           (fragments_needed - 2), (fragments_needed - 3));
    
    // enviar fragmentos en lotes
    while (current_fragment < fragments_needed && 
           fragments_sent_this_session < FRAGMENTS_PER_SESSION &&
           messages_sent_today < MAX_MESSAGES_PER_DAY) {
        
        bool is_final = (current_fragment == fragments_needed - 1);
        uint16_t offset = current_fragment * 19;  // 19 bytes por fragmento
        uint8_t payload_size;
        
        if (is_final) {
            // fragmento final - limitado por overhead de CRC (5 bytes: 1 header + 4 CRC)
            uint16_t remaining = IMAGE_SIZE - offset;
            payload_size = (remaining <= 15) ? remaining : 15;  // 15 bytes max para final
        } else {
            // fragmento normal (1 byte header)
            uint16_t remaining = IMAGE_SIZE - offset;
            payload_size = (remaining >= 19) ? 19 : remaining;
        }
        
        int result = send_image_fragment(current_fragment, fragments_needed,
                                       &compressed_image[offset], payload_size);
        
        if (result == 0) {
            printf("Fragment %d sent successfully\n", current_fragment);
            current_fragment++;
            fragments_sent_this_session++;
            messages_sent_today++;
            
            if (current_fragment >= fragments_needed) {
                transmission_complete = true;
                printf("=== IMAGE TRANSMISSION COMPLETE ===\n");
                break;
            }
        } else {
            printf("Failed to send fragment %d\n", current_fragment);
            break;
        }
    }
    
    printf("Session complete: sent %d fragments\n", fragments_sent_this_session);
    printf("Progress: %d/%d fragments (%d%%)\n", 
           current_fragment, fragments_needed, 
           (current_fragment * 100) / fragments_needed);
    printf("Messages sent today: %d/%d\n", messages_sent_today, MAX_MESSAGES_PER_DAY);
}

// funcion principal de transmision
static time_t send_image_session(void) {
    // verificar limite diario con reset automatico
    if (!can_send_messages_today()) {
        printf("Daily message limit reached (%d/%d)\n", 
               messages_sent_today, MAX_MESSAGES_PER_DAY);
        return FLEX_HoursFromNow(24);  // intentar manana de nuevo
    }
    
    if (transmission_complete) {
        printf("Image transmission complete. Starting new image immediately.\n");
        // resetear para siguiente imagen inmediatamente, no esperar siguiente dia
        current_fragment = 0;
        transmission_complete = false;
        // no resetear messages_sent_today aqui - dejar que reset diario lo maneje
    }
    
    // enviar lote de fragmentos
    send_image_batch();
    
    printf("Next session in %d hours\n", HOURS_BETWEEN_SESSIONS);
    printf("=================================\n\n");
    
    // programar siguiente sesion
    return FLEX_HoursFromNow(HOURS_BETWEEN_SESSIONS);
}

void FLEX_AppInit() {
    printf("%s\n", APPLICATION_NAME);
    printf("=== configuracion FCN de 6-BIT ===\n");
    printf("Image size: %d bytes\n", IMAGE_SIZE);
    printf("MTU size: %d bytes\n", MTU_SIZE);
    printf("Max fragments (6-bit FCN): %d (0-63)\n", MAX_FRAGMENTS);
    printf("Final fragment FCN: %d (All-1)\n", FCN_ALL1);
    printf("Fragments per session: %d\n", FRAGMENTS_PER_SESSION);
    printf("Hours between sessions: %d\n", HOURS_BETWEEN_SESSIONS);
    
    // calcular y mostrar requerimientos de fragmentos
    uint16_t fragments_needed = (IMAGE_SIZE + 18) / 19;
    printf("Required fragments for this image: %d\n", fragments_needed);
    
    if (fragments_needed > MAX_FRAGMENTS) {
        printf("ERROR: Image requires %d fragments but 6-bit FCN only allows %d!\n",
               fragments_needed, MAX_FRAGMENTS);
        printf("Consider reducing image size or using larger fragments.\n");
        return;
    }
    
    printf("FCN Order: Final=63, Previous=%d, %d, %d, ..., First=%d\n",
           fragments_needed - 2, fragments_needed - 3, fragments_needed - 4, 
           fragments_needed - 1 - (fragments_needed - 1));
    
    // inicializar seguimiento de reset diario
    time_t now = FLEX_TimeGet();
    last_reset_day = (uint16_t)(now / 86400);
    printf("Initialized on day %d\n", last_reset_day);
    
    printf("Starting 6-bit FCN image transmission...\n\n");
    
    // programar primera sesion de transmision
    FLEX_JobSchedule(send_image_session, FLEX_ASAP());
}